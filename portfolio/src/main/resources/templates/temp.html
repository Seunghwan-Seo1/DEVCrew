<!DOCTYPE html>
<html layout:decorate="~{admin}">
<head>
    <title>GPT 대화창</title>
</head>
<body>
    <div layout:fragment="content">
        <!-- 대화 히스토리가 쌓일 대화창 -->
        <div id="chat-container" style="height: 400px; border: 1px solid #ccc; overflow-y: auto; padding: 10px; background-color: #f9f9f9;">
        </div>

        <!-- 입력창과 버튼 -->
        <div style="margin-top: 10px;">
            <label for="question">질문:</label>
            <input type="text" id="question" style="width: 80%;" />
            <button onclick="askGPT()">질문하기</button>
        </div>

		 <script type="text/javascript">
		    // 대화 히스토리 관리
		    let conversationHistory = [];
		
		    // 한 글자씩 타이핑 효과를 주는 함수
		    function typeText(text, element, delay) {
		        let index = 0;
		        function type() {
		            if (index < text.length) {
		                element.innerHTML += text.charAt(index);
		                index++;
		                setTimeout(type, delay);
		            }
		        }
		        type(); // 타이핑 시작
		    }
		
		    // GPT에 질문하고 답변을 출력하는 함수
		    async function askGPT() {
		        const question = document.getElementById('question').value;
		        const chatContainer = document.getElementById('chat-container');
		
		        if (question.trim() === '') {
		            alert("질문을 입력하세요!"); // 빈 질문에 대한 경고 처리
		            return; // 빈 질문은 처리하지 않음
		        }
		
		        // 사용자 질문을 대화 히스토리에 추가
		        conversationHistory.push({ role: 'user', content: question });
		
		        // 사용자 질문을 대화창에 추가
		        const userMessage = document.createElement('div');
		        userMessage.classList.add('message', 'user-message');
		        userMessage.innerHTML = `<strong>사용자:</strong> ${question}`;
		        chatContainer.appendChild(userMessage);
		
		        // 질문 입력창 비우기
		        document.getElementById('question').value = '';
		
		        // 서버로 질문 전송 및 응답 받기
		        try {
		            const response = await fetch('/ask', {
		                method: 'POST',
		                headers: {
		                    'Content-Type': 'application/json'
		                },
		                body: JSON.stringify(conversationHistory) // 대화 히스토리 전체를 서버로 보냄
		            });
		
		            // HTTP 응답 코드가 200이 아닌 경우 처리
		            if (!response.ok) {
		                throw new Error(`서버 오류: ${response.status}`);
		            }
		
		            // 서버에서 응답 받기 (기본적으로 텍스트로 받음)
		            const responseData = await response.text();
		
		            let parsedData;
		            let gptContent;
		
		            // JSON 응답인지 확인하고 처리
		            try {
		                parsedData = JSON.parse(responseData);
		                // JSON 형식인 경우: OpenAI 응답에서 content 필드를 추출
		                gptContent = parsedData.choices[0].message.content; // 중첩된 content 접근
		            } catch (error) {
		                // JSON 형식이 아니면 기본 텍스트로 처리
		                console.log("텍스트 응답 처리");
		                gptContent = responseData;  // 그대로 텍스트로 사용
		            }
		
		            // 서버 응답을 대화 히스토리에 추가
		            conversationHistory.push({ role: 'assistant', content: gptContent });
		
		            // GPT의 응답을 대화창에 추가
		            const gptMessage = document.createElement('div');
		            gptMessage.classList.add('message', 'gpt-message');
		            chatContainer.appendChild(gptMessage);
		
		            // GPT의 응답을 타이핑 효과로 출력
		            typeText(`GPT: ${gptContent}`, gptMessage, 50); // 50ms 딜레이로 타이핑 출력
		
		            // 스크롤을 하단으로 유지
		            chatContainer.scrollTop = chatContainer.scrollHeight;
		
		        } catch (error) {
		            console.error("에러 발생: ", error); // 콘솔에 에러 출력
		            const errorMessage = document.createElement('div');
		            errorMessage.classList.add('message', 'error-message');
		            errorMessage.innerHTML = `에러 발생: ${error.message}`;
		            chatContainer.appendChild(errorMessage);
		
		            // 스크롤을 하단으로 유지
		            chatContainer.scrollTop = chatContainer.scrollHeight;
		        }
		    }
		</script>




    </div>
</body>
</html>
